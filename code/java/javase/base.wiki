%title Java基础拾遗

[[../../../index|首页]] - [[../index|Java]] - [[index|JavaSE]]
==Java基础拾遗==
----
===Java虚拟机===
`java -verbose`：显示`JVM`启动时详细的加载信息

`JVM`执行时针对的是`.class`文件对应的类，与源文件无关；只有含有`main`函数的类才能直接运行

`JVM`解释器工作的三个过程：
# 代码的装入，由类加载器完成
# 代码的校验
# 代码的执行
----
===数据类型===

# `byte`：字节型
# `char`：字符型
# `short`：短整型
# `int`：整形
# `long`：长整型
# `float`：单精度浮点型
# `double`：双精度浮点型
# `boolean`：布尔型

十六进制的浮点数必须以指数形式表示，且指数标志不能用`e`和`E`，而用`p`或`P`：`float f = 0x1.23p5f;`

对于`byte`、`char`、`short`这三种数据类型，除了`byte`转`short`外，其他无论谁转换成谁都是不安全的，如果要转换也必须使用强制类型转换

上面出现这种的情况原因是，这三个类型的数据在取值范围上不存在子集关系

`boolean`类型不能与其他任何数据类型进行转换
----
===Java语法===
`Java`方法可以在定义之前进行调用，而不需要提前声明

`Java`源文件中，如果`class`前没有`public`修饰，则源文件名可以与类名不同；而如果有`public`修饰，则源文件名与类名必须一致

十六进制必须以`0x`开头，八进制必须以`0`开头，长整型必须以`L`结尾，浮点型必须以`f`或`F`结尾（因为`Java`的浮点数默认为`double`类型，所以声明`float`类型数据时必须有`f`或`F`后缀）

`%`号取模的结果，符号永远与被除数相同。如 `5 % 3 --> 2`、`-5 % 3 --> -2`

`Java`中，`if()`、`else if()`括号中的表达式其结果必须是布尔型，与`C/C++`不同

`Java`内存分为栈内存和堆内存，栈内存用于保存变量，堆内存用于保存对象和数组，对象和数组会在栈中生成对应的引用变量

`Java`中声明数组时不能直接指定长度，这与`C/C++`大大不同<br>
可以写成如：`int[] arr = {1, 2, 3, 4};` 或 `int[] arr = new int[4];`，但不能写成`int arr[4];`

`Java`的多维数组并不像`C`语言一样需要组成整齐的矩形，每一行的元素个数不要求相等；声明多维数组时同样不能直接指定维数

对象的比较使用`==`或`equals()`，`==`判断的是两内存地址是否相等，而`equals()`判断的是两地址指向的内容是否相等

可以用`new Person().func(new Person());`的形式访问类中的私有成员

`finalize()`方法在对象被当成垃圾释放前调用，作用在于自动完成一些清理工作，相当于C＋＋的析构函数。但由于`Java`垃圾回收器启动时间不确定，所以该清理函数有可能直到程序运行结束都不会被调用

`System.gc()`方法主动唤醒`Java`垃圾回收器

静态方法不能以任何方式引用`this`和`super`关键字

静态代码块在类被载入时执行，且只执行一次，常用于进行类属性的初始化

====单态设计模式====
将类的构造函数用`static`关闭，这样就不能在类外调用时直接生成对象；在类体内定义一个静态方法，返回在类体内建立的这个对象，如`getPerson();`

====内部类====
内部类可以访问母类的成员，包括`private`成员，但母类不能直接访问内部类的成员<br>
不同于外部类的是，内部类可以使用`private`和`protected`修饰<br>
如果内部类声明为`public`，则该内部类可以被外部访问，步骤如下：<br>
# 建立母类的实例对象，`Outer outer = new Outer();`
# 通过母类的实例对象创建内部类的实例对象，`Outer.Inner inner = outer.new Inner();`

子类继承父类所有的成员变量和成员方法，但不继承父类的构造方法，但在子类中可以使用`super`关键字调用父类构造方法<br>
如果子类没有显式调用父类构造方法，也没有使用`this`关键字调用重载的其他构造方法，则默认会调用父类的无参构造方法

`final`关键字：
# `final`标记的类不能被继承
# `final`标记的方法不能被子类重写
# `final`标记的变量成为常量，只能赋值一次

使用`public static final`组合修饰的变量成为全局常量

抽象类和抽象方法都必须使用`abstract`修饰<br>
含有抽象方法的类必须被声明为抽象类

接口是一种特殊的抽象类，其所有方法都是抽象方法<br>
接口只包含常量和方法的定义，不包含变量以及方法的实现<br>
接口里的变量默认都是用`public static final`标识的

# `extends`：继承类或接口
# `implements`：实现接口

一个类可以在继承一个父类的同时实现一个或多个接口，但`extends`关键字必须在`implements`之前

可以用`instanceof`关键字来判断是否一个类实现了某个类或接口，形如：`if(a instanceof b)`，如果`a`是类`b`或接口`b`的一个实例

使用`throws`可以抛出异常，如果上一级不处理则层层向上递传，可以同时抛出多个异常

`Exception`是所有异常类的父类

一个`try`后面可以跟多个`catch`来捕捉异常，`catch(Exception e)`不能放在其他`catch`语句前面
----
===常用工具函数===
`System.arraycopy(ia, 0, ib, 0, 3);`<br>
将数组`ia`从下标`0`开始的`3`个元素复制到数组`ib`，且从下标为`0`的位置开始存储

`import java.util.*;`<br>
`Arrays.sort(arr);`<br>
对目标数组`arr`进行排序，`arr`将替换成排序后的内容
----
<red>date</red> : 2011-07-04、2012-02-21、2012-03-02
----
