%title 复合数据结构

[[../../../index|首页]] - [[../index|Go]] - [[index|Base]]
==复合数据结构==
----
===array===

数组的声明方式：`var arr [3]int`，或 `arr := [3]int{1, 2, 3}`，或者也可以省略元素的个数 `arr := [...]int{1, 2, 3}`（方括号内放置三个点号或者干脆什么也不放，如 `arr := []int{1, 2, 3}`）

当将数组作为参数传递给函数时，数组实际传入的只是它的一副本，而不是像`C语言`一样传递指针

二维数组的声明方式：`arr := [][2]int{ [2]int{1, 2}, [2]int{3, 4} }`，和其他很多语言一样，第二维的维数不能省略

上述二维数组还可以简写为：`arr := [][2]int{ {1, 2}, {3, 4} }`，当内部元素与外部声明的类型一样时，内部元素的类型声明可以省略
----
===slice===

`slice`与`array`接近，但其在有新元素加入时可以动态增加长度

`slice`总是指向底层的一个`array`，所有通过`slice`进行的改变都将反馈到底层的`array`上

`slice`是引用类型，它只是一个指向`array`的指针

可以通过下面两种方法创建`slice`

# `sli := make([]int32, 10)`：创建了拥有`10`个`0`值元素的`slice`
# `sli := arr[0:5]`：从指定数组截取下标从`0`到`4`的元素创建`slice`，不包括下标`5`（这其实就是`Python`中的切片了）

`slice`为数组提供了`指针`和`切片`功能，就像`C语言`和`Python`提供的功能一样，其切片语法和`Python`基本一致

`append`函数用于向`slice`追加元素，如果原`slice`所指向底层`array`容量不够，`append`将自动分配一个更大的`array`来存储，所以其返回的`slice`有可能指向不同的`array`

`append`的使用形式为`append(sl_name, 某个slice或某几个元素值, ...)`
----
===map===

`map`相当于`Perl`的`哈希`或`Python/Ruby`的`字典`

创建一个`map`的两种方法

# `map_name := make(map[键类型]值类型)`
# `map_name := map[键类型]值类型{键名1: 值1, 键名2: 值2 ... ,}`（最后的逗号不能省略）

使用形如`_, ok = map_name[键名]`的形式可以测试某个键是否存在，`ok`的值将为`true`或`false`

使用`delete(map_name, 键名)`可以从指定的`map`中移除键值对
----
===迭代器===

`range`可用于迭代所有常见的复合数据类型，包括字符串，其返回两个值，第一个为元素序号，第二个为元素的值，示例如下：
{{{Go
<pre class="brush: go">
package main
import "fmt"

func main(){
  arr := []int32{1, 2, 3}
  for k, v := range arr{
    fmt.Printf("arr[%d] = %d\n", k, v)
  }
}
</pre>
}}}
----
<red>date</red> : 2012-06-17、2012-11-13、2012-11-15
----
