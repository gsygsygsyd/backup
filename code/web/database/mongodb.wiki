%title MongoDB

[[../../../index|首页]] - [[../index|Web]] - [[index|DataBase]]
==MongoDB==
----
===启动服务器===

`MongoDB`默认的数据目录是`C:\data\db`，一般可以在当前工作目录下，手动建立`data\db`目录路径，然后使用下面的命令启动服务器

`mongod run --dbpath=data/db`

`MongoDB`服务器默认端口为`27017`，且默认情况下，`MongoDB`会监听比主端口号高`1000`的端口，所以可以通过访问`http://127.0.0.1:28017`获取数据库管理信息
----
===运行shell===

`MongoDB`自带功能完备的`JavaScript shell`，可以运行任何`JavaScript`程序，允许调用`JS`标准库

使用`JS shell`之前，先必须启动`MongoDB`服务器，只需执行命令`mongo`即可进入`shell`
----
===数据类型===

`MongoDB`支持的几种基本数据类型

# `null`：{"x" : null}
# `布尔`：{"x" : true}
# `64位浮点数`：`MongoDB`有三种数据类型（`32`位整数、`64`位整数、`64`位浮点数），但`JS shell`只支持这一种，{"x" : 3}、{"x" : 3.14}
# `字符串`：{"x" : "foobar"}
# `对象ID`：文档的`12`字节的唯一`ID`，{"x" : ObjectId()}
# `日期`：存储的是从标准纪元开始的毫秒数，不存储时区，{"x" : new Date()}
# `正则表达式`：{"x" : /foobar/i}
# `代码`：文档中可以包含`JS`代码，{"x" : function(){/* ... */}}
# `数组`：{"x" : ["a", "b", "c"]}
# `内嵌文档`：{"x" : {"foo" : "bar"}}
# `未定义`：{"x" : undefined}

`ObjectId`的创建规则：首先是`4`字节的`时间戳`，然后是`3`字节的`机器标识码`和`2`字节的`进程标识符`，最后是`3`字节的`自增计数器`

`ObjectId`的前三个组成部分提供了文档在`秒级别`的唯一性，而最后一个部分则在每一秒提供了`256**3`种不同的可能，这就确保了`ObjectId`的唯一性

`MongoDB`的一个设计理念：能从服务器端转移到驱动程序来做的事就尽量转移，以减轻数据库扩展的负担

基于这个理念，所以`ObjectId`通常是在客户端由驱动程序生成的，而不是由服务器来做这件事情
----
===文档===

`文档`是`MongoDB`的核心概念，也是`MongoDB`的基本数据单元，其非常类似于关系数据库的行，但远比行复杂

`文档`的存储结构类似于编程语言里的`哈希`、`散列`或`字典`，由一个个键值对有序排列而成

键可以使用任意`UTF-8`字符串，空字符（`\0`）用来表示键的结束

通常情况下，键不能以`_`开头，也不能包含`.`和`$`字符，因为它们有特殊用途

每一个文档都有一个特殊的键 "`_id`"，它在文档所处的集合中是唯一的

值可以使用多种数据类型，甚至可以是整个嵌入的文档

`MongoDB`是区分大小写的，且不允许存在重复的键
----
===集合===

`集合`就是一组文档的聚合，可以看作是没有模式的表

无模式意味着，一个集合里面的文档可以多种多样

`集合`的命名规则
# 不能含`\0`字符，空字符表示的是集合名的结束
# 不能以`system.`开头
# 不能含有保留字符`$`

`MongoDB`使用点号 `.` 来链接子集合
----
===数据库===

多个`文档`组成`集合`，多个`集合`组成`数据库`

每个`MongoDB`实例可以承载多个数据库，这些数据库之间完全独立，且都拥有独立的权限

`数据库`的命名规则
# 全部小写
# 最长`64`字节
# 不得含有`空格`、`.`、`$`、`/`、`\`、`\0`等字符

几个特殊的数据库名：`admin`、`local`、`config`
----
===MongoDB内部机理===

`MongoDB`内部使用一种名为`BSON`的轻量级二进制数据格式，`BSON`即为`Binary JSON`

`MongoDB`使用`BSON`的三个主要原因：`效率`、`可遍历性`、`性能`

`MongoDB`的传输协议和`HTTP`、`FTP`一样是一种应用层协议，但其实基本上也就是一个简单封装的`BSON`数据

在数据目录中，每个数据库都有几个独立的文件，包括一个`.ns`文件和若干数据文件，数据文件以递增的数字结尾

每个新的以数字结尾的数据文件大小会加倍，直到达到最大值，如`foo.2`就会比`foo.1`大一倍

在数据文件内部，每个数据库都是按`命名空间`组织的，每个集合的文档、索引等都有自己的`命名空间`

`命名空间`的元数据存放于数据库的`.ns`文件中

在`32`位的机器上，每个`MongoDB`数据库最大只能处理`2GB`的数据
----
===shell常用操作===

# `help`：列出`shell`级别的命令
# `db.version()`：查看当前运行的`MongoDB`服务器版本
# `db:help()`：列出数据库级别的可用命令
# `db.foo.help()`：列出集合级别的可用命令
# `show dbs`：显示所有数据库
# `show collections`：显示所有集合
# `use dbname`：切换数据库
# `db`：查看当前使用的数据库
# `exit`：退出`JS shell`

# `Object.bsonsize(post)`：查看`post`文档转成`BSON`格式的大小（单位：字节）

# `db.blog.insert(post)`：向集合中添加文档。`db`是数据库名，`blog`是集合名，`post`是文档名
# `db.blog.find(post)`：查看指定数据库的指定集合中所包含的指定文档，省略参数则列出所有文档
# `db.blog.update({title : "My Blog Post"}, post)`：更新文档。第一个参数是限制条件，用来匹配目标文档，第二个参数是新文档的名称
# `db.blog.remove({title : "My Blog Post"})`：删除文档，参数用来筛选匹配，省略参数将清空整个集合

键入函数时不带括号可以查看该函数的`JS`源代码

`MongoDB`优先索引数据库的属性，所以如果有集合名与属性名相同，则需要使用`db.getCollection("集合名")`来调用

如果集合名称中含有无效的`JS`字符，也可以借助`db.getCollection()`函数
----
===文档的新建===

单个插入：`db.foo.insert({"bar" : "baz"})`

批量插入：一次批量插入只占单个的`TCP`请求，可以避免零碎请求带来的开销，减少插入时间

如果在启动`MongoDB`服务器时加上`--objcheck`选项，则服务器就会在插入之前先检查文档结构的有效性（但这样做会牺牲性能）

`MongoDB`在插入时并不会执行代码，所以传统的注入式攻击对`MongoDB`是无效的
----
===文档的删除===

筛选删除：`db.foo.remove({"bar" : "baz"})`，后面的参数是筛选条件

集合清空：`db.foo.remove()`，删除集合中所有的文档，但不删除集合本身，原有索引也将保留

数据的删除是永久性的、不可逆的

如果想加快删除速度，最好的办法是直接删除集合，然后再重建索引
----
===文档的更新===

文档的更新操作是原子性的，若两更新同时执行，则先到达服务器的先执行，而最终结果以最后执行的那个更新操作为准

常用的几个修改器
# `$inc`：键值增加，键不存在则创建，只能用于整数、双精度浮点数等。如 `db.foo.update({"bar" : "baz"}, {"$inc" : {"num" : 1}})`
# `$set`：键存在则修改，键不存在则创建。如 `db.foo.update({"bar" : "baz"}, {"$set" : {"name" : "Ruchee"}})`
# `$unset`：删除键值对。如 `db.foo.update({"bar" : "baz"}, {"$unset" : {"name" : "Ruchee"}})`

数组修改器
# `$push`：键存在则向数组末尾插入元素，不存在则创建一个新的数组。如 `db.blog.posts.update({"title" : "A blog post"}, {$push : {"comments" : {"name" : "Ruchee", "email" : "my@ruchee.com"}}})`
# `$addToSet`：避免重复添加。如 `db.user.update({"name" : "Ruchee"}, {"$addToSet" : {"emails" : "rucheecn@gmail.com"}})`
# `$each`：与`$addToSet`结合，一次添加多个值。如 `db.user.update({"name" : "Ruchee"}, {"$addToSet" : {"emails" : {"$each" : ["my@ruchee.com", "rucheecn@gmail.com"]}}})`
# `$pop`：从数组删除元素，`{$pop : {key : 1}}`是从末尾删除，而`{$pop : {key : -1}}}`是从头部删除
# `$pull`：从数组中筛选性删除，凡匹配上的元素都将删掉

特殊的`upsert`操作：只需给`update`的第三个参数赋值为`true`即表明这是个`upsert`操作

`upsert`的特殊性在于，如果找到匹配项，则正常更新，如果找不到匹配项则把更新改为新建
----
<red>date</red> : 2012-03-26
----
