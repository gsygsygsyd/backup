%title Make自动编译

[[../../../index|首页]] - [[../index|Linux]] - [[index|GNU]]
==Make自动编译==
----
===命令行选项===
# `-f`：指定所执行的`Makefile`文件，而不使用默认值
# `-i`：忽略命令执行返回的出错信息
# `-t`：更新目标文件
# `-p`：输出所有宏定义和目标文件描述
----
===预设目标===
# `make all`：编译所有目标，等同于直接执行`make`
# `make clean`：清除之前所生成可执行文件和目标文件
# `make dist`：将程序和相关文件打包成一个压缩文件以供发布
# `make install`：将程序安装到系统
# `make uninstall`：卸载安装的程序
----
===基本规则===
基本格式：<br>
{{{MAKE
目标1 目标2 ... : 前提1 前提2 ...
	命令1
	命令2
	...
}}}
`make`的执行规则：如果目标比前提旧，那么就执行命令脚本；如果前提还有前提，则会依序回溯<br>
第一个目标必须放在行首，前面不能有空格<br>
每一个命令行都必须以制表符开始

前提和命令都是可选的<br>
没有命令的规则只能指示依赖关系<br>
没有前提的规则则指示如何构建目标，而不是何时构建

`#`；开始一行注释<br>
`CC == gcc`：变量命名，不需要分号之类的结束符<br>
`$(CC)`：引用变量，使用美元符和括号<br>
`$@`：代表目标<br>
`$^`：代表前提列表<br>
`$<`：代表一个前提
`\`：命令续行
----
===命令脚本===
`make`的每一行命令都将分别以独立的`shell`实例来运行<br>
如果想让多个命令在同一个`shell`中执行，方法之一是把它们放在同一行，以分号隔开；或者每行一条命令，但是在命令的行尾加上续行符“`\`”
----
===伪目标===
使用`.PHONY`来声明伪目标，伪目标不会自动由依赖执行，需要在执行`make`命令时指定

如：
{{{Make
.PHONY : clean
clean :
	rm *.o
}}}
----
===模式规则===
示例：<br>
{{{MAKE
test1.o test2.o : %.o : %.c
	$(CC) $(CFLAGS) -o $@ -c $<
}}}
第一部分是目标列表，第二、三部分解释如何从每个目标导出前提名称<br>
上例中，`make`会使用模式`%.o`比对目标列表中的每个目标，凡目标中符合`%`的部分就用来取代`%.c`中的百分号，由此自动产生前提

如果包含了显式的目标列表，那么就称之为“静态规则”<br>
如果省略了目标列表，则称之为“隐式规则”

模式规则支持反斜杠转义，比如`\\`、`\%`
----
===内置规则===
示例：<br>
{{{MAKE
CC = gcc
CFLAGS = -Werror -std=c99
OBJS = abc.o

abc : $(OBJS) -lm
}}}
上例与下例等效：<br>
{{{MAKE
CC = gcc
CFLAGS = -Werror -std=c99

abc : abc.o
	$(CC) $(CFLAGS) -o $@ $<
abc.o : abc.c
	$(CC) $(CFLAGS) -o $@ -c $<
}}}
----
===赋值运算符===
`=`：定义递归展开变量<br>
`:=`：定义简单展开变量<br>
`+=`：附加运算符<br>
`?=`：条件赋值运算符
----
<red>date</red> : 2011-05-25、2011-08-17
----
