%title 基础语法拾遗

[[../../../index|首页]] - [[../index|Lang]] - [[index|Lua]]
==基础语法拾遗==
----
===注释===

行注释：以两个连字符`--`开始，效果持续到该行的结尾

块注释：以`--[[`开始，以`]]`结束

常用的技巧是，使用`--[[`和`--]]`来包含注释块，如：
{{{Lua
--[[
print("Ruchee")
--]]
}}}
如果想要重新启用注释块中的代码，只需在`--[[`的前面再添加一个连字符使之变成`---[[`即可，这样开始与结尾的两个注释标签都变成了普通的行注释
----
===语言基础===

`Lua`不强制使用分号，但如果在同一行书写多条`Lua`语句时可以使用分号来分隔

`Lua`的变量默认为全局变量，如果没有初始化则默认值为`nil`，要删除一个全局变量，只需将其赋值为`nil`即可

`Lua`支持的转义字符和`C`语言基本一致

`Lua`支持多重赋值，即在一个表达式中对多个变量进行赋值，如`a, b = 10, 20`

`Lua`使用`local`来声明局部变量

`Lua`的一种惯用法：`local foo = foo`，用全局变量`foo`的值初始化局部变量`foo`，以临时保存该全局变量当前的值
----
===数据类型===

`Lua`共有`8`种数据类型

# `nil`：空，主要功能是用于区别其他任何值
# `boolean`：布尔，可选值有`true`和`false`
# `number`：数字，可以写成任意整数、小数、科学计数法的形式
# `string`：字符串
# `userdata`：自定义类型
# `function`：函数
# `thread`：线程
# `table`：表，这是`Lua`唯一的数据结构

可使用`type`函数来检测变量的数据类型，如：`print(type("Ruchee"))`

`Lua`只把`nil`和`false`视为假，其他任何情况包括数字零和空字符串都被视为真
----
===操作符===

支持所有常规的算数运算符，此外还拥有一个特殊的指数操作符`^`，如：`2^3 = 8`

对于取模运算符`%`，`x%1`的结果将是`x`的小数部分，这与`C`语言极为不同，所以有如下结论：

# `x - x%1`：代表`x`的整数部分
# `x - x%0.01`：代表`x`精确到小数点后两位的结果

对于关系运算符，`==`用于相等性测试，而`~=`则用于不等性测试，其中`nil`只与其自身相等

只能对两个数字或两个字符串做大小性比较，对于其他数据类型只能做相等性或不等性比较

`Lua`的逻辑操作符是`and`、`or`、`not`

`Lua`的`and`和`or`拥有一种特殊的短路逻辑：

# `and`：如果第一个操作数为假，则返回第一个操作数，否则返回第二个操作数
# `or`：如果第一个操作数为真，则返回第一个操作数，否则返回第二个操作数

两种基于短路逻辑的`Lua`惯用法：

# `x = x or y`：相等于`if not x then x = y end`，即如果`x`存在则值不变，如果不存在则赋值为`y`
# `a and b or c`：相等于`C`语言的`a ? b : c`，但前提是`b`不能为假，所以比较两数的大小可以简写为`max = (x > y) and x or y`

在`Lua`中，操作符的优先级如下:

# `^`：优先级最高
# `not`、`#`、`-（负号）`：优先级很高，仅次于`^`操作符
# `and`：优先级很低，仅高于`or`操作符
# `or`：优先级最低

除了指数操作符`^`和连接操作符`..`是“右结合”以外，其他操作符都是“左结合”，所以`x^y^z`等价于`x^(y^z)`

需要注意的是：`Lua`不支持`+=`、`-=`这样的复合操作符
----
===控制结构===

`Lua`支持`break`，但不支持`continue`，也不支持`switch`语句

典型的`if-else`结构：
{{{Lua
<pre class='brush: lua'>
if op == "+" then
	c = a + b
elseif op == "-" then
	c = a - b
else
	c = a * b
end
</pre>
}}}

典型的`while`结构：
{{{Lua
<pre class='brush: lua'>
while i < 10 do
	print("i = " .. i)
	i = i + 1
end
</pre>
}}}

典型的`repeat-until`结构（`repeat`循环至少会执行一次，相当于`do-while`）：
{{{Lua
<pre class='brush: lua'>
repeat
	print("i = " .. i)
	i = i + 1
until i >= 10
</pre>
}}}

典型的`for`循环结构（数字型`for`，第一个参数为起始值，第二个参数为终止值，第三个参数为步进值，可选）：
{{{Lua
<pre class='brush: lua'>
for i = 10, 1, -1 do
	print("i = " .. i)
end
</pre>
}}}

典型的`for`循环结构（泛型`for`，使用迭代器函数来遍历）：
{{{Lua
<pre class='brush: lua'>
for i, v in ipairs(tab) do
	print("tab[" .. i .. "] = " .. v)
end
</pre>
}}}

`Lua`标准库提供了以下几种常用的迭代器

# `io.lines`：迭代文件中的每行
# `pairs`：迭代`table`元素
# `ipairs`：迭代数组元素
# `string.gmatch`：迭代字符串中的单词
----
===字符串===

`Lua`的字符串不能像`C`语言一样可以直接修改，它通常是新建了一个改动过的副本，`Lua`可以高效处理长字符串，无须担心字符串的分配和释放

如果使用`[[`和`]]`来包围字符串，则可以在其中自由换行而无需使用转义字符，如：
{{{Lua
<pre class='brush: lua'>
print [[
Contenttype:text/html

<html>
<head><title> hello world </title></head>
<body>
    Hello, this is your first Lua CGI page!
</body>
</html>
]]
</pre>
}}}

如果字符串可以合法地转化成数字且当前语义环境需要数字时，则`Lua`会自动进行这种转化，如：`print("10" + 1) = 11`、`print("2" + "1") = 3`

相应地，如果当前语义环境需要字符串时，`Lua`也会自动将数字转化成字符串，如：`print(1 .. 2) = 12`

`Lua`使用两个连续的点号`..`作为字符串连接符，如果在一个数字之后使用它则需要空一个空格，以免被解析成小数点

最好是使用强制转化，这样不至于出现莫名其妙的错误：

# 字符串转数字可以使用函数`tonumber`
# 数字转字符串可以使用函数`tostring`或者在数字后面连接一个空字符串`123 .. ""`

在字符串前面放置长度操作符`#`可以获得该字符串的长度，如：`print(#"Ruchee") = 6`
----
===表结构===

`Lua`的`table`（表）相当于`Perl`的`hash`（哈希）或`Python`的`dict`（字典）

`table`既不是“值”，也不是“变量”，而是“`对象`”，一种可以动态分配的对象

`table`没有专门的声明语句，它是通过构造表达式来完成建立的

`table`是匿名的，一个`table`变量与`table`自身没有任何固定的关联性，当`table`变量的所有引用都被赋值为`nil`时，这个`table`也就被宣告消失了

如果`table`的某个元素没有初始化，则该元素的值将是`nil`

对于`tab["name"]`这样的元素引用，可以简写为`tab.name`，就像引用类的元素一样。但这种用法只适用于字符串索引，对于数字索引不适用

如果`table`的索引下标全部使用整数，则该`table`就变成了传统的数组，但不同的是，这样的`Lua`数组通常以下标`1`开始，而不是`0`

在`table`变量名前面放置一个`#`号可以获得该`table`的最后一个索引值，对于数组则对应于该数组的长度（下标从`1`开始）

`Lua`中，几种长度操作符的惯用法：

# `print(tab[#tab])`：打印最后一个元素的值
# `tab[#tab] = nil`：删除最后一个元素
# `tab[#tab + 1] = "Ruchee"`：在数组末尾添加新值

`注意`：使用数字`0`和字符串`"0"`来索引一个`table`是不同的，这是两个不同的元素

table的构造方式如下

方式一：`days = {"Sunday", "Monday", "Tuesday"}`<br>
这将初始化`days[1] = Sunday`，`days[2] = Monday`，`days[3] = Tuesday`

方式二：`nums = {x = 10, y = 20, z = 30}`<br>
这将初始化`nums["x"] = 10`，`nums["y"] = 20`，`nums["z"] = 30`，亦即`nums.x = 10`，`nums.y = 20`，`nums.z = 30`

方式三：可以在`table`中嵌套`table`，相等于多维数组的形式

在`table`中允许使用分号来代替逗号，这一般是用来将列表部分与记录部分显示区分的，如：`tab = {x = 10, y = 45; "one", "two", "three"}`
----
===函数===

调用函数时必须带括号，除非其参数是一个字符串或一个`table`构造式，比如下面的情况就可以省略括号：

# `print "Ruchee"`
# `dofile 'abc.lua'`
# `print [[多行文字]]`
# `func1 {x = 10, y = 20}`

调用函数时传递的参数个数可多可少，多的舍弃，少的赋`nil`

如果一个函数调用不是一系列表达式的最后一个元素，则不管其返回多少个值，表达式都将只能接收到第一个返回值

譬如，如果函数`func1()`返回值有`10`和`20`两个，则`x, y = func1()`可以得到`x = 10`和`y = 20`，但对于表达式`x, y = func1(), 30`则只能得到`x = 10`和`y = 30`，第二个返回值`20`被丢弃

一个函数在调用另一个函数的情况下，如果被调函数是主调函数的最后一个实参时，被调函数的所有返回值都将作为实参传入主调函数。但如果被调函数处于一个表达式中，则主调函数只能接受到其第一个返回值，多余的将丢弃

还是上面的`func1()`函数，对于`print(func1())`将输出`10 20`，而对于`print(func1() .. "abc")`则会输出`10abc`

用一个`table`构造式可以完整地接收一个函数的所有返回值，形如：`t = {func1()}`，相当于`t = {10, 20}`

`重要`：很重要的一点，只要函数调用不是一个表达式最后的元素，则都将只能取到第一个返回值，余者丢弃

如果只想取函数的第一个返回值，则只需用一对小括号将函数调用括起来即可：如`print((func1()))`将输出`10`，而不是`10 20`

特别注意，`Lua`的`return`语句不需要使用括号，这和`C`语言不同，因为在`Lua`中，小括号将起到截取第一个返回值的作用
----
===函数的变长参数===

`Lua`的函数定义中使用三个点`...`来表示变长参数列表，函数里面的元素引用该变长参数列表时同样使用三个点

如`function foo(a, b, c)`其实相当于下面的语句：
{{{Lua
<pre class='brush: lua'>
function foo(...)
	local a, b, c = ...
end
</pre>
}}}

在使用变长参数的同时可以拥有任意数目的固定参数，但固定参数必须放在变长参数的前面

使用`select()`函数可以对变长参数列表进行指定性操作

# `select('3', ...)`：返回变长数组第`3`个元素的值
# `select('#', ...)`：返回变长数组的元素个数，包括值为`nil`的元素
----
===函数的高级特性===

在`Lua`中，函数与变量没有本质的差异，函数既可以赋值给变量，也可以作为实参传递，还可以作为其他函数的返回值

`Lua`中，函数支持嵌套，内函数可以访问外函数的变量

一个函数定义本质上只是一条赋值语句，这其实就是其他语言里的“匿名函数”，如：

`function foo(x) return 2*x end` 其实相当于 `foo = function(x) return 2*x end`
----
===非全局函数===

函数可以存放在表结构中，对应有三种声明方式

第一种：
{{{Lua
<pre class='brush: lua'>
func = {}
func.foo = function(x, y) return x + y end
func.goo = function(x, y) return x - y end
</pre>
}}}

第二种：
{{{Lua
<pre class='brush: lua'>
func = {
	foo = function(x, y) return x + y end,
	goo = function(x, y) return x - y end,
}
</pre>
}}}

第三种：
{{{Lua
<pre class='brush: lua'>
func = {}
function func.foo(x, y) return x + y end
function func.goo(x, y) return x - y end
</pre>
}}}
----
===常用函数===

`tonumber()`：将目标值转化成数字，如果不能成功转化则返回值`nil`

`tostring()`：将目标值转化成字符串

`table.maxn()`：返回目标`table`的最大正索引值

`string.find()`：返回匹配字符串起始字符和结尾字符的索引值，譬如：`a, b = string.find("Lua is good", "Lua")`，`a`的值为`1`，`b`的值为`3`

`unpack()`：接受一个数组作为参数，从下标`1`开始逐个返回元素值

`io.write()`：输出文本；`string.format()`：格式化文本；可以自定义一个函数合并这两函数：
{{{Lua
<pre class='brush: lua'>
function fwrite(fmt, ...)
	return io.write(string.format(fmt, ...))
end
</pre>
}}}
这样就可以使用形如`fwrite("%d %d\n", 4, 5)`的方式调用了
----
===协同程序===

协同程序与线程类似，是一条拥有自己独立的栈、局部变量和指令指针的执行序列，同时又与其他协同程序共享全局变量和其他大部分东西

区别在于，多线程程序可以同时运行几个线程，而协同程序却需要彼此协作地运行

`Lua`将所有关于协同程序的函数放在一个名为`coroutine`的`table`中

`coroutine.create()`：创建新的协同程序，参数为一个函数，亦即该协同程序需要执行的内容，`create()`会返回一个`thread`类型的值

一个协同程序的四种状态：

# 正常（`normal`）
# 运行（`running`）
# 挂起（`suspended`）
# 死亡（`dead`）

新创建的协同程序会处于挂起状态，也就是说协同程序不会在创建时自动执行

# `coroutine.status()`：检查协同程序的状态
# `coroutine.resume()`：启动或重启某个协同程序
# `coroutine.yield()`：把一个运行中的协同程序挂起

`resume`是在保护模式中运行的，如果协同程序执行中发生错误，`Lua`是不会显示错误消息的，而是将执行权返回给`resume`调用

当一个协同程序`A`唤醒另一个协同程序`B`时，协同程序`A`所处的特殊状态称之为“正常”状态
----
<red>date</red> : 2011-10-01、2011-10-12、2011-10-13、2012-10-09合并整理
----
